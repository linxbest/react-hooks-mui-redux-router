
import { createAsyncThunk, createSlice, PayloadAction } from '@reduxjs/toolkit';
import { RootState } from '../index';
import { fetchList } from '../../apis/search';

export interface SearchState {
    value: [];
    status: 'idle' | 'loading' | 'failed';
}
  
const initialState: SearchState = {
    value: [],
    status: 'idle',
};

export const searchResult = (state: RootState) => state.search.value;
export const fetchResultAsync = createAsyncThunk(
    'search/fetchList',
    async (params: any): Promise<any> => {
      const response = await fetchList(params);
      return response.data;
    }
  );

export const searchSlice = createSlice({
    name: 'search',
    initialState,
    // The `reducers` field lets us define reducers and generate associated actions
    reducers: {
        clear: (state) => {
            // Redux Toolkit allows us to write "mutating" logic in reducers. It
            // doesn't actually mutate the state because it uses the Immer library,
            // which detects changes to a "draft state" and produces a brand new
            // immutable state based off those changes
            state.value = [];
        },
    },
    // The `extraReducers` field lets the slice handle actions defined elsewhere,
    // including actions generated by createAsyncThunk or in other slices.
    extraReducers: (builder) => {
      builder
        .addCase(fetchResultAsync.pending, (state) => {
          state.status = 'loading';
        })
        .addCase(fetchResultAsync.fulfilled, (state, action) => {
          state.status = 'idle';
          state.value = action.payload.product_trends;
          console.log('请求结果+++', state, action)
        });
    },
  });

  export default searchSlice.reducer;